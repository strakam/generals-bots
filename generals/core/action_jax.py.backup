"""
JAX-optimized action utilities using arrays and JIT-compatible functions.

Provides:
- Pure JAX array-based actions (no custom classes)
- JIT-compiled valid move mask computation
- Vectorizable action utilities
- Valid action sampling using action masks
"""

import jax
import jax.numpy as jnp
import jax.random as jrandom
from jax import lax


# Direction constants matching config.py
DIRECTIONS = jnp.array([
    [-1, 0],  # UP
    [1, 0],   # DOWN
    [0, -1],  # LEFT
    [0, 1],   # RIGHT
], dtype=jnp.int32)


def create_action(to_pass: bool = False, row: int = 0, col: int = 0, 
                  direction: int = 0, to_split: bool = False) -> jnp.ndarray:
    """
    Create an action array for JAX game.
    
    Args:
        to_pass: Whether to pass this turn
        row: Source row
        col: Source column
        direction: Direction index (0=UP, 1=DOWN, 2=LEFT, 3=RIGHT)
        to_split: Whether to split the army
    
    Returns:
        JAX array [pass, row, col, direction, split] of shape (5,)
    """
    return jnp.array([
        int(to_pass), 
        row, 
        col, 
        direction, 
        int(to_split)
    ], dtype=jnp.int32)


@jax.jit
def compute_valid_move_mask(
    armies: jnp.ndarray,
    owned_cells: jnp.ndarray,
    mountains: jnp.ndarray,
) -> jnp.ndarray:
    """
    Compute valid move mask for a given observation.
    
    A valid move originates from a cell the agent owns, has at least 2 armies,
    and does not attempt to enter a mountain nor exit the grid.
    
    Args:
        armies: [H, W] army counts
        owned_cells: [H, W] boolean mask of owned cells
        mountains: [H, W] boolean mask of mountains
    
    Returns:
        [H, W, 4] boolean mask where mask[i, j, k] indicates if moving
        from (i, j) in direction k is valid
    """
    H, W = armies.shape
    
    # Can only move from owned cells with >1 army
    can_move_from = owned_cells & (armies > 1)
    
    # Mountains are not passable
    passable = ~mountains
    
    # Initialize mask
    valid_mask = jnp.zeros((H, W, 4), dtype=jnp.bool_)
    
    # Check each direction
    for dir_idx in range(4):
        di, dj = DIRECTIONS[dir_idx]
        
        # Compute destination indices for all cells
        dest_i = jnp.arange(H)[:, None] + di
        dest_j = jnp.arange(W)[None, :] + dj
        
        # Check bounds
        in_bounds = (
            (dest_i >= 0) & (dest_i < H) &
            (dest_j >= 0) & (dest_j < W)
        )
        
        # Safe indexing: clamp to valid range for passable check
        safe_dest_i = jnp.clip(dest_i, 0, H - 1)
        safe_dest_j = jnp.clip(dest_j, 0, W - 1)
        
        # Check if destination is passable
        dest_passable = passable[safe_dest_i, safe_dest_j]
        
        # Valid if: can move from source, destination in bounds, destination passable
        valid = can_move_from & in_bounds & dest_passable
        
        valid_mask = valid_mask.at[:, :, dir_idx].set(valid)
    
    return valid_mask


def sample_valid_action_jax(
    key: jnp.ndarray,
    observation,
    allow_pass: bool = True,
) -> jnp.ndarray:
    """
    Sample a valid action for a single player from their observation.
    
    Uses the valid move mask to only select legal moves.
    
    Args:
        key: JAX random key
        observation: ObservationJax for one player [H, W, ...]
        allow_pass: Whether passing is allowed (always valid)
    
    Returns:
        Action array [5]: [pass, row, col, direction, split]
    """
    # Compute valid moves
    valid_mask = compute_valid_move_mask_obs(observation)  # [H, W, 4]
    
    # Flatten the mask to get all valid (row, col, direction) tuples
    H, W = observation.armies.shape
    
    # Get indices where valid_mask is True
    valid_positions = jnp.argwhere(valid_mask, size=H*W*4, fill_value=-1)
    
    # Count valid moves (stop at first -1)
    num_valid = jnp.sum(jnp.all(valid_positions >= 0, axis=-1))
    
    # Decide whether to pass or make a move
    key1, key2, key3 = jrandom.split(key, 3)
    
    # Pass with some probability if allowed and there are valid moves
    should_pass = allow_pass & (jrandom.uniform(key1) < 0.1)
    
    # If no valid moves, must pass
    should_pass = should_pass | (num_valid == 0)
    
    # Sample a random valid move
    move_idx = jrandom.randint(key2, (), 0, jnp.maximum(num_valid, 1))
    move_idx = jnp.minimum(move_idx, num_valid - 1)
    selected_move = valid_positions[move_idx]  # [row, col, direction]
    
    # Random split decision
    split = jrandom.randint(key3, (), 0, 2)
    
    # Build action
    action = jnp.array([
        should_pass.astype(jnp.int32),
        selected_move[0],
        selected_move[1],
        selected_move[2],
        split,
    ], dtype=jnp.int32)
    
    return action

    """
    Convenience wrapper that takes an ObservationJax NamedTuple.
    
    Args:
        observation: ObservationJax named tuple
    
    Returns:
        [H, W, 4] boolean mask of valid moves
    """
    return compute_valid_move_mask(
        observation.armies,
        observation.owned_cells,
        observation.mountains,
    )
